% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inverse_sgwt.R
\name{inverse_sgwt}
\alias{inverse_sgwt}
\title{Compute Inverse Spectral Graph Wavelet Transform.}
\usage{
inverse_sgwt(wc, evalues, evectors, b = 2)
}
\arguments{
\item{wc}{Wavelet coefficients to reconstruct the graph signal from (numeric vector).}

\item{evalues}{Eigenvalues of the Laplacian matrix (numeric vector).}

\item{evectors}{Eigenvectors of the Laplacian matrix (matrix).}

\item{b}{Parameter that controls the number of scales in the SGWT (numeric scalar). It must be greater than 1.}
}
\value{
\code{f} A graph signal obtained by applying the SGWT adjoint to \eqn{wc}{wc}.
}
\description{
\code{inverse_sgwt} computes the inverse (adjoint) Spectral Graph Wavelet Transform (SGWT) for wavelet coefficients \eqn{wc}{wc}. The computation corresponds to the frame defined by the \code{\link{tight_frame}} function. Given the tightness of the frame, the inverse is simply the application of the adjoint linear transformation to the wavelet coefficients.
}
\details{
Given wavelet coefficients \eqn{wc}{wc}, \code{inverse_sgwt} reconstructs the original graph signal using the inverse SGWT.

The eigenvalues and eigenvectors of the graph Laplacian are denoted as \eqn{\Lambda}{Lambda} and \eqn{U}{U} respectively. The parameter \eqn{b}{b} controls the number of scales, and \eqn{\lambda_{\text{max}}}{lambda_max} is the largest eigenvalue.


For each scale \eqn{j = 0, 1, \ldots, J}{j = 0, 1, ..., J}, where
\deqn{J = \left\lfloor \frac{\log(\lambda_{\text{max}})}{\log(b)} \right\rfloor + 2}{J = floor(log(lambda_max)/log(b)) + 2}, the reconstructed signal for that scale is computed as:
\deqn{
\mathbf{f}_j = (U \mathbf{wc}_j \odot g_j) U^T
}{\mathbf{f}_j = (U wc_j * g_j) U^T}
where \deqn{g_j(\lambda) = \sqrt{\psi_j(\lambda)}}{g_j(lambda) = sqrt(psi_j(lambda))} and \eqn{\odot}{*} denotes element-wise multiplication.

The final result is the sum of \eqn{\mathbf{f}_j}{f_j} across all scales to reconstruct the entire graph signal.
}
\examples{
\dontrun{
# Extract the adjacency matrix from the grid1 and compute the Laplacian
L <- laplacian_mat(grid1$sA)

# Compute the spectral decomposition of L
decomp <- eigensort(L)

# Create a sample graph signal
f <- rnorm(nrow(W))

# Compute the forward Spectral Graph Wavelet Transform
wc <- forward_sgwt(f, decomp$evalues, decomp$evectors)

# Reconstruct the graph signal using the inverse SGWT
f_rec <- inverse_sgwt(wc, decomp$evalues, decomp$evectors)
}

}
\references{
GÃ¶bel, F., Blanchard, G., von Luxburg, U. (2018). Construction of tight frames on graphs and application to denoising. In Handbook of Big Data Analytics (pp. 503-522). Springer, Cham.

de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.

Hammond, D. K., Vandergheynst, P., & Gribonval, R. (2011). Wavelets on graphs via spectral graph theory. Applied and Computational Harmonic Analysis, 30(2), 129-150.
}
\seealso{
\code{\link{forward_sgwt}}, \code{\link{tight_frame}}
}
